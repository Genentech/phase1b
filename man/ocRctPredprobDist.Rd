% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ocRctPredprobDist.R
\name{ocRctPredprobDist}
\alias{ocRctPredprobDist}
\title{Calculate operating characteristics for RCT against SOC,
using the predictive probability method with beta priors}
\usage{
ocRctPredprobDist(
  nnE,
  pE,
  pS,
  deltaE,
  deltaF,
  phiL = 1 - phiFu,
  phiFu = 1 - phiL,
  phiU,
  relativeDelta = FALSE,
  tT,
  tF,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  weights,
  weightsS,
  randRatio = 1,
  sim,
  wiggle = FALSE,
  nnF = nnE,
  decision1 = TRUE
)
}
\arguments{
\item{nnE}{(\code{numeric}):\cr sample size or sizes where study can be stopped for Efficacy decision. If \code{0} or \code{NULL} and
\code{length(nnE) = 1} then no Efficacy looks are performed.}

\item{pE}{(\code{number}):\cr Response rate in Treatment group.}

\item{pS}{(\code{number}):\cr Response rate in Control group.}

\item{deltaE}{(\code{number}):\cr margin by which the response rate in the treatment group should
be better than in the standard of care or control or \code{S} group in Efficacy looks only.
Note that this can also be negative as well.}

\item{deltaF}{(\code{number}):\cr margin by which the response rate in the treatment group should
be better than in the standard of care or control or \code{S} group in Futility looks only.
Note that this can also be negative as well.}

\item{phiL}{(\code{number}):\cr lower threshold on the predictive probability.}

\item{phiFu}{(\code{number}):\cr upper threshold on the predictive probability.}

\item{phiU}{(\code{number}):\cr upper threshold on the predictive probability.}

\item{relativeDelta}{(\code{flag}):\cr If \code{TRUE}, then a \code{relativeDelta} is used. Represents that a minimum
response rate in magnitude of \code{delta} of the \code{S} non-responding patients. See \code{\link[=postprobDist]{postprobDist()}}.}

\item{tT}{(\code{number}):\cr threshold of which assumed \code{truep} exceeds acceptable threshold of \code{p0}.}

\item{tF}{(\code{number}):\cr threshold of which assumed \code{truep} does not exceed threshold of \code{p1}.}

\item{parE}{(\code{numeric}):\cr alpha and beta parameters for the prior on the treatment population.
Default set at alpha = 1, beta = 1, or uniform prior.}

\item{parS}{(\code{numeric}):\cr parameters for beta distribution. If it is a matrix, it needs to have 2 columns,
and each row corresponds to each component of a beta-mixture distribution for the \code{S} group.}

\item{weights}{(\code{numeric}):\cr the mixture weights of the beta mixture prior.}

\item{weightsS}{(\code{numeric}):\cr weights for the \code{S} group.}

\item{randRatio}{(\code{numeric}):\cr The randomisation ratio between treatment and control. Must be greater than 0 and maximum of 1.}

\item{sim}{(\code{number}):\cr number of simulations.}

\item{wiggle}{(\code{flag}):\cr generate random look locations (not default). If \code{wiggle = TRUE} and \code{nnE = nnF}, then all wiggled
looks are the same between \code{nnE} and \code{nnF}.}

\item{nnF}{(\code{numeric}):\cr sample size or sizes where study can be stopped for Efficacy decision. If \code{0} or \code{NULL} and
\code{length(nnF) = 1} then no Futility looks are performed.}

\item{decision1}{(\code{flag}):\cr Flag if \code{decision1 = TRUE} then Decision 1 rules will be used, otherwise Decision 2 rules will be used.}
}
\description{
We emulate a randomized-controlled trial setting where at any given sample size,
there exists the number of patients enrolled in either standard of care (SOC) or control arm, and
a treatment or experimental arm. The allocation of patients will depend on the
randomization ratio set by the user and is rounded to the next higher integer.
Therefore the sequence of patients is determined from the start, such that the number of
patients in both arms is constant across trial simulations, however the number of patients
within the control and treatment arm is determined by the randomisation ratio.
Interim looks are for sample sizes below that of the final sample size.
}
\details{
Final looks are only performed at the maximum sample size.

At each interim or final look, a futility or efficacy or both can be performed.

The rules for Stop, Go and Gray Zone (where applicable), and use of beta priors are the same
as in \code{\link[=ocPredprobDist]{ocPredprobDist()}} where the only difference here is to emulate a
randomized-controlled trial setting.

The returned value is a list with the following elements:
\itemize{
\item \code{oc}: matrix with operating characteristics with the following details:
\item \code{ExpectedN}: expected number of patients in the trials in both treatment and SOC group
\item \code{ExpectedNactive} : the mean of the number of patients in treatment arm
\item \code{ExpectedNcontrol}: the mean of the number of patients in control arm
\item \code{PrStopEarly}: probability to stop the trial early (before reaching the maximum sample size)
\item \code{PrEarlyEff}: probability of Early Go decision
\item \code{PrEarlyFut}: probability of Early Stop decision
\item \code{PrEfficacy}: probability of Go decision
\item \code{PrFutility}: probability of Stop decision
\item \code{PrGrayZone}: probability of Evaluate or "Gray Zone" decision (between Go and Stop)
\item \code{Decision} : results in \code{logical} with \code{TRUE} as Go, \code{FALSE} as Stop and \code{NA} as Evaluate decision.
\item \code{SampleSize} : numeric of sample sizes from \code{nnE} or \code{nnF} or both.
\item \code{SampleSizeActive} : numeric of sample sizes in the treatment or experimental arm.
\item \code{SampleSizeControl} : numeric of sample sizes in either standard of care (SOC) or control arm.
\item \code{union_nn} : unique \code{nnE} and \code{nnF} looks.
\item \code{wiggled_nnE} : user input for \code{nnE} with random distance applied.
\item \code{wiggled_nnF} : user input for \code{nnF} with random distance applied.
\item \code{wiggled_dist} : magnitude of random distance applied in order of input looks.
\item \code{params} : all user input arguments.
}
}
\examples{
# When `relativeDelta = TRUE`:
set.seed(2000)
ocRctPredprobDist(
  nnE = c(10, 20, 30),
  pE = 0.3,
  pS = 0.3,
  deltaE = 0.2,
  deltaF = 0.1,
  phiU = 0.8,
  phiFu = 0.2,
  relativeDelta = TRUE,
  tT = 0.6,
  tF = 0.4,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  weights = 1,
  weightsS = 1,
  randRatio = 1,
  sim = 50,
  wiggle = FALSE,
  nnF = c(10, 20, 30),
  decision1 = TRUE
)

# When `relativeDelta = FALSE`:
set.seed(2000)
ocRctPredprobDist(
  nnE = c(10, 20, 30),
  pE = 0.3,
  pS = 0.3,
  deltaE = 0.2,
  deltaF = 0.1,
  phiU = 0.8,
  phiFu = 0.2,
  relativeDelta = FALSE,
  tT = 0.6,
  tF = 0.4,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  weights = 1,
  weightsS = 1,
  randRatio = 1,
  sim = 50,
  wiggle = FALSE,
  nnF = c(10, 20, 30),
  decision1 = TRUE
)

# Only one Futility look:
set.seed(2000)
ocRctPredprobDist(
  nnE = c(10, 20, 30),
  pE = 0.3,
  pS = 0.3,
  deltaE = 0.2,
  deltaF = 0.1,
  phiU = 0.8,
  phiFu = 0.2,
  relativeDelta = FALSE,
  tT = 0.6,
  tF = 0.4,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  weights = 1,
  weightsS = 1,
  randRatio = 1,
  sim = 50,
  wiggle = FALSE,
  nnF = 20,
  decision1 = TRUE
)

# When `deltaF = 0`:
set.seed(2000)
ocRctPredprobDist(
  nnE = c(10, 20, 30),
  pE = 0.3,
  pS = 0.3,
  deltaE = 0.2,
  deltaF = 0,
  phiU = 0.8,
  phiFu = 0.2,
  relativeDelta = FALSE,
  tT = 0.6,
  tF = 0.4,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  weights = 1,
  weightsS = 1,
  randRatio = 1,
  sim = 50,
  wiggle = FALSE,
  nnF = c(10, 20, 30),
  decision1 = TRUE
)
}

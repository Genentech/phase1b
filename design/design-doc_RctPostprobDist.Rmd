---
title: "Design document for ocRctPostprobDist"
output: html_notebook
---

Calculate operating characteristics for RCT against SOC,
using the posterior probability method with beta priors

We emulate a randomized-controlled trial setting where at any given sample size,
there exists the number of patients enrolled in either standard of care (SOC) or control arm, and
a treatment or experimental arm. The allocation of patients will depend on the
randomization ratio set by the user and is rounded to the next higher integer.
Therefore the sequence of patients is determined from the start, such that the number of
patients in both arms is constant across trial simulations, however the number of patients
within the control and treatment arm is determined by the randomisation ratio.
Interim looks are for sample sizes below that of the final sample size.
Final looks are only performed at the maximum sample size,
At each interim or final look, a futility or efficacy or both can be performed.

The rules for Stop, Go and Gray Zone (where applicable) are the same as in [ocPredprob()] however
as with [ocPredprobDist()], the margin of difference differ depending on whether it is a Go or Stop decision
(`deltaE` and `deltaF` is employed instead of `delta`)

 @return A list with the following elements:
 - `oc`: matrix with operating characteristics with the following details:
    - `ExpectedN`: expected number of patients in the trials in both treatment and SOC group
    - `ExpectedNactive` : the mean of the number of patients in treatment arm
    - `ExpectedNcontrol`: the mean of the number of patients in control arm
    - `PrStopEarly`: probability to stop the trial early (before reaching the
                    maximum sample size)
    - `PrEarlyEff`: probability of Early Go decision
    - `PrEarlyFut`: probability of for Early Stop decision
    - `PrEfficacy`: probability of Go decision
    - `PrFutility`: probability of Stop decision
    - `PrGrayZone`: probability between Go and Stop ,"Evaluate" or Gray decision zone
 - `Decision` : numeric of results with `TRUE` as Go decision, `FALSE` as Stop and `NA` as gray zone.
 - `SampleSize` : numeric of sample sizes from `nnE` or `nnF` or both.
 - `wiggled_nnE` : user input for `nnE` with random distance applied.
 - `wiggled_nnF` : user input for `nnF` with random distance applied.
 - `wiggled_dist` : magnitude of random distance applied in order of input looks.
 - `params` : all user input arguments.

 <!-- The randomization works as follows. According to the randomization ratio and -->
 <!-- the maximum sample size, patients are allocated to the treatment and SOC -->
 <!-- arms. The number of patients in the active treatment arm is rounded to the -->
 <!-- next higher integer. That is, the sequence of patients is determined from -->
 <!-- the start, such that the number of patients in both arms is constant across -->
 <!-- trial simulations. -->

 <!-- The randomized controlled trial (RCT) is stopped for efficacy if the -->
 <!-- posterior probability to be at least deltaE better than the control is -->
 <!-- larger than tU, and stopped for futility if the posterior probability to be -->
 <!-- at least deltaF worse than the control is larger than tL. Otherwise the -->
 <!-- trial is continued, and at the maximum sample size it may happen that no -->
 <!-- decision is made ("gray zone"). -->

 <!-- A variation can be requested when \code{deltaF} is set to \code{NULL}. Then -->
 <!-- the futility decision is made when the probability to be deltaE better than -->
 <!-- the control is lower than 1 - tL.  -->

# Input parameters
```{r}
input <- list(
  nn = c(10, 20, 30),
  nnE = c(10, 20, 30),
  pE = 0.4,
  pS = 0.3,
  deltaE = 0.2,
  deltaF = 0.1,
  relativeDelta = FALSE,
  tL = 0.8,
  tU = 0.8,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  randRatio = 1,
  ns = 10000,
  nr = FALSE,
  d = NULL,
  nnF = c(10, 20, 30),
  truep = 0.4,
  sim = 5,
  Nmax = 15,
  NmaxControl = 15,
  decision <- rep(NA, 5)
)
n <- nActive <- nControl <- integer(5) # initiate n
ns <- as.integer(5) # sim
nL <- length(input$nn) # the max of nn or we can do Nmax
Nstart <- input$nn[1]
Nmax <- input$nn[nL]
```
# Example of vintage function
```{r}
ocRctPostprobDist(
  nn = input$nn,
  pE = input$pE,
  pS = input$pS,
  deltaE = input$deltaE,
  deltaF = input$deltaF,
  relativeDelta = FALSE,
  tL = 0.8,
  tU = 0.8,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  randRatio = 1,
  ns = 100,
  nr = FALSE,
  d = NULL,
  nnF = input$nnF
)
```
# h_get_decisionDist_rct
```{r}
h_get_decisionDist_rct <- function(nnr,
                                   nnrE,
                                   nnrF,
                                   pE,
                                   pS,
                                   parE = c(1, 1),
                                   parS = c(1, 1),
                                   tL,
                                   tU,
                                   deltaE,
                                   deltaF,
                                   relativeDelta,
                                   randRatio = 1,
                                   rct = FALSE) {
  assert_numeric(nnr, finite = TRUE, any.missing = FALSE)
  assert_numeric(nnrE, max.len = length(nnr), any.missing = FALSE)
  assert_numeric(nnrF, max.len = length(nnr), any.missing = FALSE)
  assert_number(pE, lower = 0, upper = 1)
  assert_number(pS, lower = 0, upper = 1)
  assert_numeric(parE, lower = 0, finite = TRUE, any.missing = FALSE)
  assert_numeric(parS, lower = 0, finite = TRUE, any.missing = FALSE)
  assert_number(tL, lower = 0, upper = 1)
  assert_number(tU, lower = 0, upper = 1)
  assert_number(deltaE, finite = TRUE)
  assert_number(deltaF, finite = TRUE)
  assert_flag(relativeDelta)

  index_look <- 1
  size_look <- nnr[index_look]
  all_sizes <- decision <- nActive <- nControl <- NA
  activeProp <- randRatio / (randRatio + 1)
  NmaxActive <- ceiling(activeProp * Nmax)
  NmaxControl <- Nmax - NmaxActive

  isActive <- sample(
    x = rep(c(TRUE, FALSE), c(NmaxActive, NmaxControl)),
    size = Nmax,
    replace = FALSE
  )
  response <- rbinom(Nmax, size = 1, prob = ifelse(isActive, pE, pS))

  activeProp <- randRatio / (randRatio + 1)
  NmaxActive <- ceiling(activeProp * Nmax)
  NmaxControl <- Nmax - NmaxActive


  while (is.na(decision) && index_look <= length(nnr)) {
    ## current data in both arms:
    xActive <- response[which(isActive[1:size_look])]
    xControl <- response[which(!isActive[1:size_look])]

    if (size_look %in% nnrF) {
      qL <- postprobDist(
        x = sum(xControl),
        n = length(xControl),
        xS = sum(xActive),
        nS = length(xActive),
        delta = deltaF,
        relativeDelta = relativeDelta,
        parE = parS,
        parS = parE
      )
      decision <- ifelse(qL >= tL, FALSE, NA)
    }
    if (size_look %in% nnrE) {
      qU <- postprobDist(
        x = sum(xActive),
        n = length(xActive),
        xS = sum(xControl),
        nS = length(xControl),
        delta = deltaE,
        relativeDelta = relativeDelta,
        parE = parE,
        parS = parS
      )
      decision <- ifelse(qU < tU, decision, TRUE)
    }
    nActive <- length(xActive)
    nControl <- length(xControl)
    all_sizes <- size_look
    index_look <- index_look + 1
    size_look <- nnr[index_look]
  }
  list(
    decision = decision,
    all_sizes = all_sizes,
    nActive = nActive,
    nControl = nControl
  )
}
```
# Example of running `h_get_decisionDist_rct`
```{r}
example_dist <- h_get_distance(nn = c(10, 20, 30))
looks <- h_get_looks(dist = example_dist, nnE = c(10, 20, 30), nnF = c(10, 20, 30))
looks_nnrE <- looks$nnrE
looks_nnrF <- looks$nnrF

h_get_decisionDist_rct(
  nnr = input$nn,
  nnrE = looks$nnrE,
  nnrF = looks$nnrF,
  pE = input$pE,
  pS = input$pS,
  parE = c(1, 1),
  parS = c(1, 1),
  tL = input$tL,
  tU = input$tU,
  deltaE = input$deltaE,
  deltaF = input$deltaF,
  relativeDelta = input$relativeDelta,
  rct = TRUE
)
```
# helper also works when `relativeDelta = FALSE`
```{r}
example_dist <- h_get_distance(nn = c(10, 20, 30))
looks <- h_get_looks(dist = example_dist, nnE = c(10, 20, 30), nnF = c(10, 20, 30))
looks_nnrE <- looks$nnrE
looks_nnrF <- looks$nnrF

h_get_decisionDist_rct(
  nnr = input$nn,
  nnrE = looks$nnrE,
  nnrF = looks$nnrF,
  pE = input$pE,
  pS = input$pS,
  parE = c(1, 1),
  parS = c(1, 1),
  tL = input$tL,
  tU = input$tU,
  deltaE = input$deltaE,
  deltaF = input$deltaF,
  relativeDelta = TRUE,
  rct = TRUE
)
```
# h_get_oc_rct

```{r}
h_get_oc_rct <- function(all_sizes, Nmax, nActive, nControl, decision, nnrE, nnrF) {
  assert_numeric(all_sizes)
  # assert_numeric(nnr, any.missing = FALSE)
  assert_logical(decision, len = length(all_sizes))
  assert_numeric(nnrE, lower = 0, upper = max(nnrE))
  assert_numeric(nnrF, lower = 0, upper = max(nnrF))

  sim <- length(all_sizes)

  # Nmax <- max(nnr)
  data.frame(
    ExpectedN = mean(all_sizes, na.rm = TRUE), # but there should not be na at all
    ExpectedNactive = mean(nActive),
    ExpectedNcontrol = mean(nControl),
    PrStopEarly = mean(all_sizes < Nmax, na.rm = TRUE),
    PrEarlyEff = sum(decision * (all_sizes < Nmax), na.rm = TRUE) / sim,
    PrEarlyFut = sum((1 - decision) * (all_sizes < Nmax), na.rm = TRUE) / sim,
    PrEfficacy = sum(decision, na.rm = TRUE) / sim,
    PrFutility = sum(1 - decision, na.rm = TRUE) / sim,
    PrGrayZone = sum(is.na(decision)) / sim
  )
}
```

# Example for h_get_oc_rct
```{r}
set.seed(2000)
result <- ocRctPostprobDist(
  nn = input$nn,
  pE = input$pE,
  pS = input$pS,
  deltaE = input$deltaE,
  deltaF = input$deltaF,
  relativeDelta = TRUE,
  tL = input$tL,
  tU = input$tU,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  randRatio = 1,
  ns = 100,
  nr = FALSE,
  d = NULL,
  nnF = input$nnF
)

oc <- h_get_oc_rct(
  all_sizes = result$SampleSize,
  Nmax = max(input$nn),
  nActive = result$SampleSizeActive,
  nControl = result$SampleSizeControl,
  decision = result$Decision,
  nnrE = input$nnE,
  nnrF = input$nnF
)
oc
```
# User facing function
```{r}
new_RctPostProbDist <- function(nnE,
                                pE, # truep
                                pS,
                                deltaE,
                                deltaF,
                                relativeDelta = FALSE,
                                tL,
                                tU,
                                parE = c(a = 1, b = 1),
                                parS = c(a = 1, b = 1),
                                rct = FALSE,
                                randRatio = 1,
                                sim,
                                wiggle = FALSE,
                                nnF = nnE) {
  # some starting inits ocPostprobDist
  if (sim < 50000) {
    warning("Advise to use sim >= 50000 to achieve convergence")
  }
  decision <- all_sizes <- vector(length = sim)
  nnE <- sort(nnE)
  nnF <- sort(nnF)
  nn <- sort(unique(c(nnF, nnE)))
  nL <- length(nn)
  nn <- sort(unique(c(nnF, nnE)))

  nL <- length(nn)
  Nstart <- nn[1]
  Nmax <- nn[nL]

  for (k in seq_len(sim)) {
    if (length(nn) != 1 && wiggle) {
      dist <- h_get_distance(nn = nn)
      nnr <- h_get_looks(dist = dist, nnE = nnE, nnF = nnF)
      nnrE <- nnr$nnrE
      nnrF <- nnr$nnrF
    } else {
      nnrE <- nnE
      nnrF <- nnF
    }
    nnr <- unique(c(nnrE, nnrF))
    tmp <- h_get_decisionDist_rct(
      nnr = nnr,
      nnrE = nnrE,
      nnrF = nnrF,
      pE = pE,
      pS = pS,
      parE = c(1, 1),
      parS = c(1, 1),
      tL = tL,
      tU = tU,
      deltaE = deltaE,
      deltaF = deltaF,
      relativeDelta = relativeDelta,
      rct = rct,
    )
    decision[k] <- tmp$decision
    all_sizes[k] <- tmp$all_sizes
    nActive[k] <- tmp$nActive
    nControl[k] <- tmp$nControl
  }
  oc <- h_get_oc_rct(all_sizes = all_sizes, Nmax = Nmax, nActive = nActive, nControl = nControl, decision = decision, nnrE = nnrE, nnrF = nnrF)
  list(
    oc = oc,
    ExpectedN = mean(all_sizes),
    ExpectedNactive = mean(nActive),
    ExpectedNcontrol = mean(nControl),
    Decision = decision,
    SampleSize = all_sizes,
    SampleSizeActive = nActive,
    SampleSizeControl = nControl,
    union_nn = nnr,
    wiggled_nnE = nnrE,
    wiggled_nnF = nnrF,
    wiggle_dist = dist,
    params = as.list(match.call(expand.dots = FALSE))
  )
}
```
# Example of new_RctPostProbDist when `relativeDelta = TRUE` and comparing with vintage function below:
```{r}
set.seed(2000)
new_RctPostProbDist(
  nnE = input$nn,
  pE = input$pE,
  pS = input$pS,
  deltaE = input$deltaE,
  deltaF = input$deltaF,
  relativeDelta = TRUE,
  tL = input$tL,
  tU = input$tU,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  rct = TRUE,
  randRatio = 1,
  sim = 50,
  wiggle = FALSE,
  nnF = input$nnF
)
```

```{r}
set.seed(2000)
ocRctPostprobDist(
  nn = input$nn,
  pE = input$pE,
  pS = input$pS,
  deltaE = input$deltaE,
  deltaF = input$deltaF,
  relativeDelta = TRUE,
  tL = input$tL,
  tU = input$tU,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  randRatio = 1,
  ns = 50,
  nr = FALSE,
  d = NULL,
  nnF = input$nnF
)
```

# Example of new_ocRctPostProbDist when `relativeDelta = FALSE`.
```{r}
set.seed(1090)
new_RctPostProbDist(
  nnE = input$nn,
  pE = input$pE,
  pS = input$pS,
  deltaE = input$deltaE,
  deltaF = input$deltaF,
  relativeDelta = FALSE,
  tL = input$tL,
  tU = input$tU,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  rct = FALSE,
  randRatio = 1,
  sim = 100,
  wiggle = FALSE,
  nnF = input$nnF
)
```
# Example of ocRctPostProbDist when `relativeDelta = FALSE`.
```{r}
set.seed(1090)
oc <- ocRctPostprobDist(
  nn = input$nn,
  pE = input$pE,
  pS = input$pS,
  deltaE = input$deltaE,
  deltaF = input$deltaF,
  relativeDelta = FALSE,
  tL = input$tL,
  tU = input$tU,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  randRatio = 1,
  ns = 100,
  nr = FALSE,
  d = NULL,
  nnF = input$nnF
)
oc
```
# annotation of steps of vintage function

Initially we set certain parameters through establishing too the randomization ratio
Then we simulate `sim` number of times the possible sample sizes for all looks with random distance applied if `wiggle = TRUE`.
```{r}
ocRctPostprobDist <- function(nn, pE, pS, deltaE, deltaF, relativeDelta = FALSE,
                              tL = 0.8, tU = 0.8,
                              parE = c(a = 1, b = 1),
                              parS = c(a = 1, b = 1),
                              randRatio = 1,
                              ns = 10000, nr = FALSE, d = NULL, nnF = nn) {
  ## checks
  stopifnot(
    is.probability(pE),
    is.probability(pS),
    is.probability(deltaE),
    is.bool(relativeDelta),
    is.probability(tL),
    is.probability(tU),
    randRatio > 0,
    is.scalar(ns),
    is.bool(nr)
  )

  if (!is.null(deltaF)) {
    stopifnot(is.probability(abs(deltaF)))
  }
  ## s: decision reject H0 (TRUE) or fail to reject (FALSE)
  ##    during trial if continuing (NA)
  nnE <- sort(nn)
  nnF <- sort(nnF)
  s <- rep(NA, ns)
  n <- nActive <- nControl <- integer(length(s))
  ns <- as.integer(ns)
  nn <- sort(unique(c(nnF, nnE)))
  nL <- length(nn) # 3rd
  Nstart <- nn[1] # first element 10
  Nmax <- nn[nL] # third element  30

  ## proportion of active patients:
  activeProp <- randRatio / (randRatio + 1) # 0.5

  ## determine number of active and control patients
  NmaxActive <- ceiling(activeProp * Nmax) # 15 patients max that active can have
  NmaxControl <- Nmax - NmaxActive # 15 patients max that control patients can have

  if (nr && is.null(d)) { # if no distance given, distance is measured. So this is get_distance
    ## set parameter d for randomly generating look locations
    d <- floor(min(nn - c(0, nn[-nL])) / 2) # 3, c(10, 20, 30)
  }
  nnr <- nn # c(10, 20, 30)
  nnrE <- nnE # c(10, 20, 30)
  nnrF <- nnF # c(10, 20, 30)
  ## simulate a clinical trial ns times

  for (k in 1:ns) {
    if (nr && (d > 0)) { # if distance given, then distance will be calculated as wiggled distance
      ## randomly generate look locations
      dd <- sample(-d:d,
        size = nL - 1, replace = TRUE,
        prob = 2^(c(-d:0, rev(-d:(-1))) / 2)
      )
      nnr <- nn + c(dd, 0)
      nnrE <- nnr[nn %in% nnE]
      nnrF <- nnr[nn %in% nnF]
    }
    ## simulate sequence of patients
    isActive <- sample(
      x = rep(c(TRUE, FALSE), c(NmaxActive, NmaxControl)), # active pts have an NmaxActive counts
      size = Nmax,
      replace = FALSE
    )
    #  [1]  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE
    # [15] FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE
    # [29] FALSE  TRUE
    ## simulate sequence of responses. So for each above, generate a 1 or 0 according to pE and pS
    x <- stats::rbinom(Nmax, 1,
      prob = ifelse(isActive, pE, pS) # out of all patients, if isActive == TRUE, the prob of success is pE, otherwise pS
    )
    # [1] 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 1 0 0 0 1 1 0 0 1 0 1 0 0 0 1
    ## start trial
    j <- 1
    i <- nnr[j]

    while (is.na(s[k]) && (j <= length(nnr))) { # when there is no decision and we are look 1, 2, 3.
      ## current data in both arms:
      xActive <- x[which(isActive[1:i])] # [1] 0 0 1 0 4 patients here
      xControl <- x[which(!isActive[1:i])] # [1] 0 0 0 0 0 0 6 patients here

      ## compute the two probabilities
      if (!is.null(deltaF) && i %in% nnrF) { # if there is an nnF, and a size look that is in nnrF
        qL <- postprobDist(
          x = sum(xControl), n = length(xControl),
          xS = sum(xActive), nS = length(xActive),
          delta = deltaF,
          relativeDelta = relativeDelta,
          parE = parS, parS = parE
        )
      }

      qU <- postprobDist(
        x = sum(xActive), n = length(xActive),
        xS = sum(xControl), nS = length(xControl),
        delta = deltaE,
        relativeDelta = relativeDelta,
        parE = parE, parS = parS
      )

      if (!is.null(deltaF)) { # if there is a deltaF
        if (i %in% nnrF) {
          s[k] <- ifelse(qL >= tL, FALSE, NA)
        }

        if (i %in% nnrE) { # if size look is in nnrE
          s[k] <- ifelse(qU < tU, s[k], TRUE)
        }
      }
      # else {
      #   if (i %in% nnrF) {
      #     s[k] <- ifelse(qU <= 1 - tL, FALSE, NA)
      #   }
      #
      #   if (i %in% nnrE) {
      #     s[k] <- ifelse(qU < tU, s[k], TRUE)
      #   }
      # }

      ## sample sizes: total and in both arms
      n[k] <- i
      nActive[k] <- length(xActive)
      nControl[k] <- length(xControl)

      j <- j + 1
      i <- nnr[j]
    }
  }

  oc <- cbind(
    ExpectedN = mean(n),
    ExpectedNactive = mean(nActive),
    ExpectedNcontrol = mean(nControl),
    PrStopEarly = mean(n < Nmax),
    PrEarlyEff = sum(s * (n < Nmax), na.rm = TRUE) / ns,
    PrEarlyFut = sum((1 - s) * (n < Nmax), na.rm = TRUE) / ns,
    PrEfficacy = sum(s, na.rm = TRUE) / ns,
    PrFutility = sum(1 - s, na.rm = TRUE) / ns,
    PrGrayZone = sum(is.na(s) / ns)
  )

  return(list(
    oc = oc, Decision = s, SampleSize = n,
    SampleSizeActive = nActive,
    SampleSizeControl = nControl,
    nn = nn, nnE = nnE, nnF = nnF,
    params = as.list(match.call(expand.dots = FALSE))
  ))
}
```
Comparing vintage and new user facing functions

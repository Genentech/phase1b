---
title: "Design Document for ocPredprob.R"
output: html_document
date: "2024-01-08"
---
design details
multiple looks @ 10, 20, 30 patients
True response rate of the treatment group=0.4

stop for efficacy (deltaE): P(pE > pS + deltaE) >tU
stop for futility (deltaF): P(pE < pS - deltaF) >tL
where pE is the response rate of treatment group, pS is the response rate of
control group. Both of them are random variables.

Design notes :

Three helper functions assist. Two from ocPostprob.R. The only one specialised for ocPostprobDist is `h_get_decisionDist` which gives the end result.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
h_get_decision_predprob <- function(nnr, truep, p0, p1, parE = c(1, 1), nnE, nnF, tL, tU) {
  index_look <- 1
  assert_numeric(nnr)
  size_look <- nnr[index_look]
  all_sizes <- decision <- NA
  response <- stats::rbinom(max(nnr), size = 1, truep)
  assert_numeric(response, lower = 0, upper = 1)
  # while (is.na(s[k]) && (j <= length(nnr))) {
  #   if (i %in% nnrF) {
  #     qL <- 1 - predprob(x = sum(x[1:i]), n = i, Nmax = Nmax, p = p1, thetaT = 1 - tFu, parE = parE)$result
  #
  #     s[k] <- ifelse(qL > phiFu, FALSE, NA)
  #   }
  #
  #   if (i %in% nnrE) {
  #     q <- predprob(x = sum(x[1:i]), n = i, Nmax = Nmax, p = p0, thetaT = tT, parE = parE)$result
  #
  #     s[k] <- ifelse(q >= phiU & !(i < Nmax & phiU == 1), TRUE, s[k])
  #   }
  #
  #   n[k] <- i
  #   j <- j + 1
  #   i <- nnr[j]
  # }

  while (is.na(decision) && index_look <= length(nnr)) {
    if (size_look %in% nnF) {
      qL <- 1 - predprob(x = sum(x[1:i]), n = i, Nmax = Nmax, p = p1, thetaT = 1 - tFu, parE = parE)$result
      assert_number(qL, lower = 0, upper = 1)
      decision <- ifelse(qL >= tL, FALSE, NA)
    }
    if (size_look %in% nnE) {
      qU <- predprob(x = sum(x[1:i]), n = i, Nmax = Nmax, p = p0, thetaT = tT, parE = parE)$result
      assert_number(qU, lower = 0, upper = 1)
      decision <- ifelse(qU < tU, decision, TRUE)
    }
    all_sizes <- size_look
    index_look <- index_look + 1
    size_look <- nnr[index_look]
  }
  list(
    decision = decision,
    all_sizes = all_sizes
  )
}
```

```{r}
h_get_oc <- function(all_sizes, nnr, decision, nnrE, nnrF) {
  sim <- length(all_sizes)
  assert_logical(decision, len = sim)
  assert_numeric(all_sizes)
  assert_numeric(nnrE, lower = 0, upper = max(nnrE))
  assert_numeric(nnrF, lower = 0, upper = max(nnrF))
  data.frame(
    ExpectedN = mean(all_sizes, na.rm = TRUE),
    PrStopEarly = mean(all_sizes < max(nnrF), na.rm = TRUE),
    PrEarlyEff = sum(decision * (all_sizes < max(nnrE)), na.rm = TRUE) / sim,
    PrEarlyFut = sum((1 - decision) * (all_sizes < max(nnrF)), na.rm = TRUE) / sim,
    PrEfficacy = sum(decision, na.rm = TRUE) / sim,
    PrFutility = sum(1 - decision, na.rm = TRUE) / sim,
    PrGrayZone = sum(is.na(decision)) / sim
  )
}
```


```{r cars}
ocPredprob <- function(nnE, truep, p0, p1, tL, tU, parE = c(1, 1),
                       sim = 50000, wiggle = FALSE, nnF = nnE) {
  nn <- sort(unique(c(nnF, nnE)))
  assert_number(sim, lower = 1, finite = TRUE)
  assert_flag(wiggle)
  if (sim < 50000) {
    warning("Advise to use sim >= 50000 to achieve convergence")
  }
  decision <- vector(length = sim)
  all_sizes <- vector(length = sim)
  for (k in seq_len(sim)) {
    if (length(nn) != 1 && wiggle) {
      dist <- h_get_distance(nn = nn)
      nnr <- h_get_looks(dist = dist, nnE = nnE, nnF = nnF)
      nnrE <- nnr$nnrE
      nnrF <- nnr$nnrF
    } else {
      nnrE <- nnE
      nnrF <- nnF
    }



    # while (is.na(s[k]) && (j <= length(nnr))) {
    #   if (i %in% nnrF) {
    #     qL <- 1 - predprob(x = sum(x[1:i]), n = i, Nmax = Nmax, p = p1, thetaT = 1 - tFu, parE = parE)$result
    #
    #     s[k] <- ifelse(qL > phiFu, FALSE, NA)
    #   }
    #
    #   if (i %in% nnrE) {
    #     q <- predprob(x = sum(x[1:i]), n = i, Nmax = Nmax, p = p0, thetaT = tT, parE = parE)$result
    #
    #     s[k] <- ifelse(q >= phiU & !(i < Nmax & phiU == 1), TRUE, s[k])
    #   }
    #
    #   n[k] <- i
    #   j <- j + 1
    #   i <- nnr[j]
    # }



    nnr <- unique(c(nnrE, nnrF))
    tmp <- h_get_decision_predprob(
      nnr = nnr,
      truep = truep, p0 = p0, p1 = p1,
      parE = c(1, 1), nnE = nnrE,
      nnF = nnrF, tL = tL, tU = tU
    )
    decision[k] <- tmp$decision
    all_sizes[k] <- tmp$all_sizes
  }
  oc <- h_get_oc(all_sizes = all_sizes, nnr = nnr, decision = decision, nnrE = nnrE, nnrF = nnrF)
  list(
    oc = oc,
    Decision = decision,
    SampleSize = all_sizes,
    union_nn = nnr,
    input_nnE = nnE,
    input_nnF = nnF,
    wiggled_nnE = nnrE,
    wiggled_nnF = nnrF,
    wiggle_dist = dist,
    params = as.list(match.call(expand.dots = FALSE))
  )
}

ocPredprob <- function(nn, p, p0, p1 = p0, tT, tFu = 1 - tT, phiL = 1 - phiFu, phiU, phiFu = 1 - phiL,
                       parE = c(1, 1),
                       ns = 10000, nr = FALSE, d = NULL, nnF = nn) {
  # Calculate operating characteristics via simulation
  # nn: vector of look locations
  # s: decision reject H0 (TRUE) or fail to reject (FALSE)
  #    during trial if continuing (NA)
  #   nn <- sort(unique(c(nnF, nnE)))
  #   assert_number(sim, lower = 1, finite = TRUE)
  #   assert_flag(wiggle)
  #   assert_flag(randomdist)
  if (phiL + phiFu != 1) {
    warning("Both phiL and phiFu arguments are specified, phiL will be overwrite by 1-phiFu")
  }

  nnE <- sort(nn)
  nnF <- sort(nnF)
  s <- rep(NA, ns)
  n <- s
  nn <- sort(unique(c(nnF, nnE)))
  nL <- length(nn)
  Nstart <- nn[1]
  Nmax <- nn[nL]


  if (nr && is.null(d)) {
    # set parameter d for randomly generating look locations
    d <- floor(min(nn - c(0, nn[-nL])) / 2)
  }
  nnr <- nn
  nnrE <- nnE
  nnrF <- nnF

  for (k in 1:ns) {
    # simulate a clinical trial ns times
    if (nr && (d > 0)) {
      # randomly generate look locations
      dd <- sample(-d:d,
        size = nL - 1, replace = TRUE,
        prob = 2^(c(-d:0, rev(-d:(-1))) / 2)
      )
      nnr <- nn + c(dd, 0)


      nnrE <- nnr[nn %in% nnE]
      nnrF <- nnr[nn %in% nnF]
    }
    x <- stats::rbinom(Nmax, 1, p)
    j <- 1
    i <- nnr[j]
    # while (is.na(s[k]) && (j <= length(nnr))) {
    #   if (i %in% nnrF) {
    #     qL <- 1 - predprob(x = sum(x[1:i]), n = i, Nmax = Nmax, p = p1, thetaT = 1 - tFu, parE = parE)$result
    #
    #     s[k] <- ifelse(qL > phiFu, FALSE, NA)
    #   }
    #
    #   if (i %in% nnrE) {
    #     q <- predprob(x = sum(x[1:i]), n = i, Nmax = Nmax, p = p0, thetaT = tT, parE = parE)$result
    #
    #     s[k] <- ifelse(q >= phiU & !(i < Nmax & phiU == 1), TRUE, s[k])
    #   }
    #
    #   n[k] <- i
    #   j <- j + 1
    #   i <- nnr[j]
    # }
  }
  oc <- cbind(
    ExpectedN = mean(n), PrStopEarly = mean(n < Nmax),
    PrEarlyEff = sum(s * (n < Nmax), na.rm = TRUE) / ns,
    PrEarlyFut = sum((1 - s) * (n < Nmax), na.rm = TRUE) / ns,
    PrEfficacy = sum(s, na.rm = TRUE) / ns,
    PrFutility = sum(1 - s, na.rm = TRUE) / ns,
    PrGrayZone = sum(is.na(s) / ns)
  )

  return(list(
    oc = oc, Decision = s, SampleSize = n,
    nn = nn, nnE = nnE, nnF = nnF,
    params = as.list(match.call(expand.dots = FALSE))
  ))
}
```



```{r pressure, echo=FALSE}
plot(pressure)
```

---
title: "Design_doc_ocPredprobDist"
output: html_document
date: "2024-02-15"
---
Success means that at the end of the trial the posterior probability is:
  `Pr(P_E > P_S + delta_0 | data) >= thetaT`.

Where `P_E` is the response rate of the treatment or `E`group and
  `P_S` is the response rate of the standard of care of `S` group.
  `delta` is the desired improvement from the standard of care.
 There are two evaluations of delta as desired improvement from standard of care:
    1. The absolute case when `relativeDelta = FALSE`
    2. relative as when `relativeDelta = TRUE`.
  Please see note in [postprobDist()] for elaborate definition of `delta` and `relativeDelta`.

Then the predictive probability for success is:
  `pp = sum over i: Pr(Y = i | x , n)*I{Pr(P_E > P_S + delta | x,Y=i) >= thetaT}`,
where `Y` is the number of future responses in the treatment group and `x` is
the current number of responses in the treatment group out of `n`.
Prior is `P_E ~ beta(a, b)` and uniform is a `beta(1,1)`.
However, a beta mixture prior can also be specified. Analogously
for `P_S` either a uniform beta prior or a beta mixture prior can be
specified.

Also data on the `S` might be available. Then the predictive probability is
more generally defined as :
  `pp = sum over i, j: Pr(Y = i | x, n)*Pr(Z = j | xS, nS )*I{Pr(P_E > P_S + delta | x,xS, Y=i, Z=j ) >= thetaT}`
where `Z` is the future number of responses in the `S` group, and `xS` is the
current number of responses in the `S` group.

# Stop criteria for Efficacy and Futility are further defined.
As a start, for single arm or two-arm study are as follows, trial success or not is defined as follows.
If `relativeDelta = TRUE` then a non-zero (but maximum 1) `deltaE`or `deltaF` is applied :

# A trial will be successful at final if :

# `Pr(truep > P_S + deltaE) => tU`

# A trial will be unsuccessful at final if :

#' `Pr(truep < P_S - deltaF) > tF`

These definitions are incorporated at Interim and Final.
They have two variations, Decision 1 and Decision 2 as follows:

#' ## Decision 1:
#' The criteria for Decision 1 for Interim looks are :
#' - interim GO =  P(successful trial at final) > phiU
#' - interim STOP = P(successful trial at final) < phiL
#'
#' The criteria for Decision 1 for Final looks are:
#' - Final GO = P( RR > p0 + delta | data) => tT
#' - Final STOP = P(RR > p0 - delta | data ) < tT
#'
#' ## Decision 2:
#' The criteria for Decision 2 for Interim looks are :
#' - Interim GO : P ( successful at final) > phiU
#' - Interim STOP : P ( unsuccessful at final ) > phiFu
#'
#' The criteria for Decision 2 for Futility looks are :
#' - Final GO = P( RR > p0 + delta ) > tT
#' - Final STOP = P( RR < p1 - delta ) > tF

## helper function for decision 1

```{r}
h_get_decision_one_predprobDist <- function(
    nnr,
    truep,
    p0,
    parE = c(1, 1),
    nnE,
    nnF,
    tT,
    phiU,
    phiL,
    xS,
    nS,
    relativeDelta,
    deltaE,
    deltaF) {
  assert_numeric(nnr, lower = 1, sorted = TRUE)
  assert_number(truep, lower = 0, upper = 1)
  assert_number(p0, lower = 0, upper = 1)
  assert_numeric(parE, min.len = 2, any.missing = FALSE)
  assert_numeric(nnE, lower = 1, any.missing = FALSE, sorted = TRUE)
  assert_numeric(nnF, lower = 1, any.missing = FALSE, sorted = TRUE)
  assert_number(tT, lower = 0, upper = 1)
  assert_number(phiU, lower = 0, upper = 1)
  assert_number(phiL, lower = 0, upper = 1)
  index_look <- 1
  Nmax <- max(nnr)
  decision <- NA
  response <- stats::rbinom(Nmax, size = 1, prob = truep)
  #' ## Decision 1:
  #' The criteria for Decision 1 for Interim looks are :
  #' - interim GO =  P(successful trial at final) > phiU
  #' - interim STOP = P(successful trial at final) < phiL
  while (is.na(decision) && index_look < length(nnr)) {
    size_look <- nnr[index_look]
    if (size_look %in% nnE) {
      interim_qU <- predprobDist(
        x = sum(response[1:size_look]),
        n = size_look,
        xS = xS,
        nS = nS,
        Nmax = Nmax,
        NmaxControl = NmaxControl,
        delta = deltaE,
        relativeDelta = relativeDelta,
        parE = parE,
        weights = weights,
        thetaT = tT,
      )$result
      decision <- ifelse(interim_qU > phiU, TRUE, decision)
    }
    if (size_look %in% nnF) {
      interim_qU <- predprobDist(
        x = sum(response[1:size_look]),
        n = size_look,
        xS = xS,
        nS = nS,
        Nmax = Nmax,
        NmaxControl = NmaxControl,
        delta = deltaE,
        relativeDelta = relativeDelta,
        parE = parE,
        weights = weights,
        thetaT = tT,
      )$result
      decision <- ifelse(interim_qU < phiL, FALSE, decision)
    }
    index_look <- index_look + 1
  }
  #' The criteria for Decision 1 for Final looks are:
  #' - Final GO = P( RR > p0 + delta | data) => tT
  #' - Final STOP = P(RR > p0 - delta | data ) < tT
  if (is.na(decision)) {
    size_look <- nnr[index_look]
    if (size_look %in% nnE) {
      final_eff_qU <- postprobDist(
        x = sum(response[1:size_look]),
        n = size_look,
        xS = xS,
        nS = sum(response[1:size_look]),
        delta = deltaF,
        relativeDelta = relativeDelta,
        parE = parE,
        weights = weights, # for activeBetamixPost
        parS = parS,
        weights = weightsS # for controlBetamixPost
      )
    }
    decision <- ifelse(final_eff_qU >= tT, TRUE, NA)
  }
  if (size_look %in% nnF) {
    final_fu_qU <- postprobDist(
      x = sum(response[1:size_look]),
      n = size_look,
      xS = xS,
      nS = sum(response[1:size_look]),
      delta = deltaE,
      relativeDelta = relativeDelta,
      parE = parE,
      weights = weights, # for activeBetamixPost
      parS = parS,
      weights = weightsS # for controlBetamixPost
    )
    decision <- ifelse(final_fu_qU < tT, FALSE, decision)
  }
  list(
    decision = decision,
    all_sizes = size_look
  )
}
```


## helper function for decision 2

#' Decision 2:
#' The criteria for Decision 2 for Interim looks are :
#' - Interim GO : P ( successful at final) > phiU
#' - Interim STOP : P ( unsuccessful at final ) > phiFu
#'
#' The criteria for Decision 2 for Futility looks are :
#' - Final GO = P( RR > p0 + delta ) > tT
#' - Final STOP = P( RR < p1 - delta ) > tF
```{r}
h_get_decision_two_predprobDist <- function(
    nnr,
    truep,
    p0,
    parE = c(1, 1),
    nnE,
    nnF,
    tT,
    phiU,
    phiL,
    xS,
    nS,
    relativeDelta,
    deltaE,
    deltaF) {
  assert_numeric(nnr, lower = 1, sorted = TRUE)
  assert_number(truep, lower = 0, upper = 1)
  assert_number(p0, lower = 0, upper = 1)
  assert_numeric(parE, min.len = 2, any.missing = FALSE)
  assert_numeric(nnE, lower = 1, any.missing = FALSE, sorted = TRUE)
  assert_numeric(nnF, lower = 1, any.missing = FALSE, sorted = TRUE)
  assert_number(tT, lower = 0, upper = 1)
  assert_number(phiU, lower = 0, upper = 1)
  assert_number(phiL, lower = 0, upper = 1)
  index_look <- 1
  Nmax <- max(nnr)
  decision <- NA
  response <- stats::rbinom(Nmax, size = 1, prob = truep)
  #' The criteria for Decision 2 for Interim looks are :
  #' - Interim GO : P ( successful at final) > phiU
  #' - Interim STOP : P ( unsuccessful at final ) > phiFu
  while (is.na(decision) && index_look < length(nnr)) {
    size_look <- nnr[index_look]
    # x, n,
    # xS = 0,
    # nS = 0,
    # Nmax,
    # NmaxControl = 0,
    # delta = 0,
    # relativeDelta = FALSE,
    # parE = c(a = 1, b = 1),
    # weights,
    # parS = c(a = 1, b = 1),
    # weightsS,
    # thetaT
    if (size_look %in% nnE) {
      interim_qU <- predprobDist(
        x = sum(response[1:size_look]),
        n = size_look,
        xS = xS,
        nS = nS,
        Nmax = Nmax,
        NmaxControl = NmaxControl,
        delta = deltaE,
        relativeDelta = relativeDelta,
        parE = parE,
        weights = weights,
        thetaT = tT,
      )$result
      decision <- ifelse(interim_qU > phiU, FALSE, decision)
    }
    if (size_look %in% nnF) {
      interim_qU <- 1 - predprobDist(
        x = sum(response[1:size_look]),
        n = size_look,
        xS = xS,
        nS = nS,
        Nmax = Nmax,
        NmaxControl = NmaxControl,
        delta = deltaE,
        relativeDelta = relativeDelta,
        parE = parE,
        weights = weights,
        thetaT = tT,
      )$result
      decision <- ifelse(interim_qU > phiFu, FALSE, decision)
    }
    index_look <- index_look + 1
  }
  #' The criteria for Decision 2 for Futility looks are :
  #' - Final GO = P( RR > p0 + delta ) > tT
  #' - Final STOP = P( RR < p1 - delta ) > tF
  if (is.na(decision)) {
    size_look <- nnr[index_look]
    if (size_look %in% nnE) {
      final_eff_qU <- postprobDist(
        x = sum(response[1:size_look]),
        n = size_look,
        xS = xS,
        nS = sum(response[1:size_look]),
        delta = deltaF,
        relativeDelta = relativeDelta,
        parE = parE,
        parS = parS
      )
    }
    decision <- ifelse(final_eff_qU > tT, TRUE, NA)
  }
  if (size_look %in% nnF) {
    final_fu_qU <- 1 - postprobDist(
      x = sum(response[1:size_look]),
      n = size_look,
      xS = xS,
      nS = sum(response[1:size_look]),
      delta = deltaE,
      relativeDelta = relativeDelta,
      parE = parE,
      parS = parS
    )
    decision <- ifelse(final_fu_qU > tF, FALSE, decision)
  }
  list(
    decision = decision,
    all_sizes = size_look
  )
}
```

# Adapted from vintage helper `h_get_decisionDist` used in `ocPostprobDist`
```{r}
h_get_decisionPredProbDist <- function(nnr,
                                       nnrE,
                                       nnrF,
                                       truep,
                                       parE = c(1, 1),
                                       parS = c(1, 1),
                                       tT,
                                       deltaE,
                                       deltaF,
                                       relativeDelta) {
  assert_numeric(nnr, finite = TRUE, any.missing = FALSE)
  assert_numeric(nnrE, max.len = length(nnr), any.missing = FALSE)
  assert_numeric(nnrF, max.len = length(nnr), any.missing = FALSE)
  assert_number(truep, lower = 0, upper = 1)
  assert_numeric(parE, lower = 0, finite = TRUE, any.missing = FALSE)
  assert_numeric(parS, lower = 0, finite = TRUE, any.missing = FALSE)
  assert_number(tT, lower = 0, upper = 1)
  assert_number(deltaE, finite = TRUE)
  assert_number(deltaF, finite = TRUE)
  assert_flag(relativeDelta)

  index_look <- 1
  size_look <- nnr[index_look]
  all_sizes <- decision <- NA
  response <- stats::rbinom(max(nnr), size = 1, truep)

  while (is.na(decision) && index_look <= length(nnr)) {
    if (size_look %in% nnrF) {
      qL <- postprobDist(
        x = 0,
        n = 0,
        xS = sum(response[1:size_look]),
        nS = size_look,
        delta = deltaF,
        relativeDelta = relativeDelta,
        parE = parS,
        parS = parE
      )
      decision <- ifelse(qL >= tL, FALSE, NA)
    }
    if (size_look %in% nnrE) {
      qU <- postprobDist(
        x = sum(response[1:size_look]),
        n = size_look,
        xS = 0,
        nS = 0,
        delta = deltaE,
        relativeDelta = relativeDelta,
        parE = parE,
        parS = parS
      )
      decision <- ifelse(qU < tU, decision, TRUE)
    }
    all_sizes <- size_look
    index_look <- index_look + 1
    size_look <- nnr[index_look]
  }
  list(
    decision = decision,
    all_sizes = all_sizes
  )
}
```

# new user facing function

```{r}
new_ocPredprobDist <- function(
    nnE,
    truep,
    p0,
    p1 = p0,
    deltaE = 0.1,
    deltaF = 0.1,
    relativeDelta = FALSE,
    tT = 1 - tF,
    tF = 1 - tT,
    phiU,
    phiL = 1 - phiFu,
    phiFu = 1 - phiL,
    parE = c(1, 1),
    parS = c(1, 1),
    sim = 50000,
    wiggle = FALSE,
    nnF = nnE,
    decision1 = TRUE) {
  assert_numeric(nnE, lower = 1, any.missing = FALSE, sort = TRUE)
  assert_number(truep, lower = 0, upper = 1)
  assert_number(p0, lower = 0, upper = 1)
  assert_number(p1, lower = 0, upper = 1)
  assert_number(tT, lower = 0, upper = 1)
  assert_number(tF, lower = 0, upper = 1)
  assert_number(phiL, lower = 0, upper = 1)
  assert_number(phiU, lower = 0, upper = 1)
  assert_number(phiFu, lower = 0, upper = 1)
  assert_numeric(parE, min.len = 2, any.missing = FALSE)
  assert_number(sim, lower = 1, finite = TRUE)
  assert_flag(wiggle)
  assert_numeric(nnF, lower = 1, any.missing = FALSE, sort = TRUE)
  assert_flag(decision1)

  nn <- sort(unique(c(nnF, nnE)))
  if (sim < 50000) {
    warning("Advise to use sim >= 50000 to achieve convergence")
  }
  decision <- vector(length = sim)
  all_sizes <- vector(length = sim)
  for (k in seq_len(sim)) {
    if (length(nn) != 1 && wiggle) {
      # if we have more than one look in nnF and nnE, we don't wiggle
      dist <- h_get_distance(nn = nn)
      nnr <- h_get_looks(dist = dist, nnE = nnE, nnF = nnF)
      nnrE <- nnr$nnrE
      nnrF <- nnr$nnrF
    } else {
      dist <- 0
      nnrE <- nnE
      nnrF <- nnF
    }
    nnr <- unique(sort(c(nnrE, nnrF)))
    tmp <- if (decision1) {
      h_get_decision_one_predprobDist(
        nnr = nnr,
        truep = truep,
        p0 = p0,
        parE = parE,
        nnE = nnrE,
        nnF = nnrF,
        tT = tT,
        phiU = phiU,
        phiL = phiL,
        xS = xS,
        nS = nS,
        relativeDelta = relativeDelta,
        deltaE = deltaE,
        deltaF = deltaF
      )
    } else {
      h_get_decision_two_predprobDist(
        nnr = nnr,
        truep = truep,
        p0 = p0,
        parE = parE,
        nnE = nnrE,
        nnF = nnrF,
        tT = tT,
        phiFu = phiFu,
        phiU = phiU
      )
    }
    decision[k] <- tmp$decision
    all_sizes[k] <- tmp$all_sizes
  }
  oc <- h_get_oc_predprob(all_sizes = all_sizes, nnr = nnr, decision = decision)
  list(
    oc = oc,
    Decision = decision,
    SampleSize = all_sizes,
    wiggled_nnrE = nnrE,
    wiggled_nnrF = nnrF,
    dist = dist,
    params = as.list(match.call(expand.dots = FALSE))
  )
}
```


# Examples to compare with vintage function
```{r}
set.seed(20)
res1 <- ocPredprobDist( # is this decision 1 or 2, and is delta absolute or relative ?
  nn = c(10, 20, 30),
  p = 0.4,
  delta = 0.1,
  tT = 0.6,
  phiL = 0.2,
  phiU = 0.8,
  parE = c(1, 1),
  parS = c(5, 25),
  ns = 10
)
res1$oc

res2 <- new_ocPredprobDist(
  nnE = c(10, 20, 30),
  truep = 0.4,
  p0 = 0.6,
  p1 = 0.6,
  deltaE = 0.1,
  deltaF = 0.1,
  relativeDelta = FALSE,
  tT = 0.6,
  tF = 1 - 0.6,
  # tFu = 1 - tT,
  phiL = 0.2,
  phiU = 0.8,
  # phiFu = 1 - phiL,
  parE = c(1, 1),
  parS = c(5, 25),
  sim = 10000,
  wiggle = FALSE,
  nnF = nnE,
  decision1 = TRUE
)
```
# vintage function
```{r}
ocPredprobDist <- function(nn, p, delta = 0, deltaFu = delta, relativeDelta = FALSE, tT, tFu = 1 - tT,
                           phiL = 1 - phiFu, phiU, phiFu = 1 - phiL,
                           parE = c(a = 1, b = 1), parS = c(a = 1, b = 1),
                           ns = 10000, nr = FALSE, d = NULL, nnF = nn) {
  if (phiL + phiFu != 1) {
    warning("Both phiL and phiFu arguments are specified, phiL will be overwrite by 1-phiFu")
  }

  nnE <- sort(nn)
  nnF <- sort(nnF)
  s <- rep(NA, ns)
  n <- s
  nn <- sort(unique(c(nnF, nnE)))
  nL <- length(nn)
  Nstart <- nn[1]
  Nmax <- nn[nL]
  if (nr && is.null(d)) {
    ## set parameter d for randomly generating look locations
    d <- floor(min(nn - c(0, nn[-nL])) / 2)
  }
  nnr <- nn
  nnrE <- nnE
  nnrF <- nnF

  for (k in 1:ns) {
    ## simulate a clinical trial ns times
    if (nr && (d > 0)) {
      ## randomly generate look locations
      dd <- sample(-d:d,
        size = nL - 1, replace = TRUE,
        prob = 2^(c(-d:0, rev(-d:(-1))) / 2)
      )
      nnr <- nn + c(dd, 0)


      nnrE <- nnr[nn %in% nnE]
      nnrF <- nnr[nn %in% nnF]
    }
    x <- stats::rbinom(Nmax, 1, p)
    j <- 1
    i <- nnr[j]
    while (is.na(s[k]) && (j <= length(nnr))) {
      if (i %in% nnrF) {
        qL <- 1 - predprobDist(
          x = sum(x[1:i]), n = i, Nmax = Nmax, delta = deltaFu,
          relativeDelta = relativeDelta,
          thetaT = 1 - tFu,
          parE = parE, parS = parS
        )$result

        s[k] <- ifelse(qL >= phiFu, FALSE, NA)
      }

      if (i %in% nnrE) {
        qU <- predprobDist(
          x = sum(x[1:i]), n = i, Nmax = Nmax, delta = delta,
          relativeDelta = relativeDelta,
          thetaT = tT,
          parE = parE, parS = parS
        )$result
        s[k] <- ifelse(qU < phiU, s[k], TRUE)
      }


      n[k] <- i
      j <- j + 1
      i <- nnr[j]
    }
  }
  oc <- cbind(
    ExpectedN = mean(n), PrStopEarly = mean(n < Nmax),
    PrEarlyEff = sum(s * (n < Nmax), na.rm = TRUE) / ns,
    PrEarlyFut = sum((1 - s) * (n < Nmax), na.rm = TRUE) / ns,
    PrEfficacy = sum(s, na.rm = TRUE) / ns,
    PrFutility = sum(1 - s, na.rm = TRUE) / ns,
    PrGrayZone = sum(is.na(s) / ns)
  )

  return(list(
    oc = oc, Decision = s, SampleSize = n,
    nn = nn, nnE = nnE, nnF = nnF,
    params = as.list(match.call(expand.dots = FALSE))
  ))
}
```

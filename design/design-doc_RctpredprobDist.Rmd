---
title: "Design document for ocRctPostprobDist"
output: html_notebook
---

#' Calculate operating characteristics for RCT against SOC,
#' using the posterior probability method with beta priors
#'
#' The randomization works as follows. According to the randomization ratio and
#' the maximum sample size, patients are allocated to the treatment and SOC
#' arms. The number of patients in the active treatment arm is rounded to the
#' next higher integer. That is, the sequence of patients is determined from
#' the start, such that the number of patients in both arms is constant across
#' trial simulations.
#'
#' The randomized controlled trial (RCT) is stopped for efficacy if the
#' posterior probability to be at least deltaE better than the control is
#' larger than tU, and stopped for futility if the posterior probability to be
#' at least deltaF worse than the control is larger than tL. Otherwise the
#' trial is continued, and at the maximum sample size it may happen that no
#' decision is made ("gray zone").
#'
#' A variation can be requested when \code{deltaF} is set to \code{NULL}. Then
#' the futility decision is made when the probability to be deltaE better than
#' the control is lower than 1 - tL.

# Input parameters
```{r}
input <- list(
  nn = c(10, 20, 30),
  pE = 0.4,
  pS = 0.3,
  deltaE = 0.2,
  deltaF = 0.1,
  relativeDelta = FALSE,
  tL = 0.8,
  tU = 0.8,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  randRatio = 1,
  ns = 10000,
  nr = FALSE,
  d = NULL,
  nnF = c(10, 20, 30)
)
sim <- 10
nnE <- sort(input$nn)
nnF <- sort(nnF)
decision <- rep(NA, sim)
n <- nActive <- nControl <- integer(length(decision)) # initiate n
ns <- as.integer(ns) # sim
nn <- sort(unique(c(nnF, nnE)))
nL <- length(nn) # the max of nn or we can do Nmax
Nstart <- nn[1]
Nmax <- nn[nL]
```
# Example of vintage function
```{r}
ocRctPostprobDist(
  nn = input$nn,
  pE = input$pE,
  pS = input$pS,
  deltaE = input$deltaE,
  deltaF = input$deltaF,
  relativeDelta = FALSE,
  tL = 0.8,
  tU = 0.8,
  parE = c(a = 1, b = 1),
  parS = c(a = 1, b = 1),
  randRatio = 1,
  ns = 1,
  nr = FALSE,
  d = NULL,
  nnF = input$nnF
)
```

```{r}
h_get_decisionDist_rct <- function(nnr,
                                   nnrE,
                                   nnrF,
                                   truep,
                                   parE = c(1, 1),
                                   parS = c(1, 1),
                                   tL,
                                   tU,
                                   deltaE,
                                   deltaF,
                                   relativeDelta) {
  assert_numeric(nnr, finite = TRUE, any.missing = FALSE)
  assert_numeric(nnrE, max.len = length(nnr), any.missing = FALSE)
  assert_numeric(nnrF, max.len = length(nnr), any.missing = FALSE)
  assert_number(truep, lower = 0, upper = 1)
  assert_numeric(parE, lower = 0, finite = TRUE, any.missing = FALSE)
  assert_numeric(parS, lower = 0, finite = TRUE, any.missing = FALSE)
  assert_number(tL, lower = 0, upper = 1)
  assert_number(tU, lower = 0, upper = 1)
  assert_number(deltaE, finite = TRUE)
  assert_number(deltaF, finite = TRUE)
  assert_flag(relativeDelta)

  index_look <- 1
  size_look <- nnr[index_look]
  all_sizes <- decision <- nActive <- nControl <- NA
  response <- stats::rbinom(max(nnr), size = 1, truep)

  while (is.na(decision) && index_look <= length(nnr)) {
    ## current data in both arms:
    xActive <- x[which(isActive[1:i])]
    xControl <- x[which(!isActive[1:i])]

    if (size_look %in% nnrF) {
      qL <- postprobDist(
        x = sum(xControl),
        n = length(xControl),
        xS = sum(xActive),
        nS = length(xActive),
        delta = deltaF,
        relativeDelta = relativeDelta,
        parE = parS,
        parS = parE
      )
      decision <- ifelse(qL >= tL, FALSE, NA)
    }
    if (size_look %in% nnrE) {
      qU <- postprobDist(
        x = sum(xActive),
        n = length(xActive),
        xS = sum(xControl),
        nS = length(xControl),
        delta = deltaE,
        relativeDelta = relativeDelta,
        parE = parE,
        parS = parS
      )
      decision <- ifelse(qU < tU, decision, TRUE)
    }
    nActive[k] <- length(xActive)
    nControl[k] <- length(xControl)
    all_sizes <- size_look
    index_look <- index_look + 1
    size_look <- nnr[index_look]
  }
  list(
    decision = decision,
    all_sizes = all_sizes,
    nActive = nActive,
    nControl = xControl
  )
}
```

```{r}
h_get_oc_rct <- function(all_sizes, nnr, decision, nnrE, nnrF) {
  assert_numeric(all_sizes)
  assert_numeric(nnr, any.missing = FALSE)
  assert_logical(decision, len = length(all_sizes))
  assert_numeric(nnrE, lower = 0, upper = max(nnrE))
  assert_numeric(nnrF, lower = 0, upper = max(nnrF))

  sim <- length(all_sizes)
  Nmax <- max(nnr)
  data.frame(
    ExpectedN = mean(all_sizes, na.rm = TRUE),
    PrStopEarly = mean(all_sizes < Nmax, na.rm = TRUE),
    PrEarlyEff = sum(decision * (all_sizes < Nmax), na.rm = TRUE) / sim,
    PrEarlyFut = sum((1 - decision) * (all_sizes < Nmax), na.rm = TRUE) / sim,
    PrEfficacy = sum(decision, na.rm = TRUE) / sim,
    PrFutility = sum(1 - decision, na.rm = TRUE) / sim,
    PrGrayZone = sum(is.na(decision)) / sim
  )
}
```

```{r}
new_RctPostProbDist <- function(nnE,
                                pE, # truep
                                pS,
                                deltaE,
                                deltaF,
                                relativeDelta = FALSE,
                                tL,
                                tU,
                                parE = c(a = 1, b = 1),
                                parS = c(a = 1, b = 1),
                                rct = FALSE,
                                randRatio = 0,
                                sim,
                                wiggle = FALSE,
                                nnF = nnE) {
  # some starting inits ocPostprobDist
  if (sim < 50000) {
    warning("Advise to use sim >= 50000 to achieve convergence")
  }
  decision <- vector(length = sim)
  all_sizes <- vector(length = sim)
  nnE <- sort(nnE)
  nnF <- sort(nnF)
  nn <- sort(unique(c(nnF, nnE)))
  nL <- length(nn)
  nn <- sort(unique(c(nnF, nnE)))

  nL <- length(nn)
  Nstart <- nn[1]
  Nmax <- nn[nL]
  activeProp <- randRatio / (randRatio + 1)
  NmaxActive <- ceiling(activeProp * Nmax)
  NmaxControl <- Nmax - NmaxActive
  activeProp <- randRatio / (randRatio + 1)
  NmaxActive <- ceiling(activeProp * Nmax)
  NmaxControl <- Nmax - NmaxActive
  response <- rbinom(Nmax, size = 1, prob = ifelse(rct == TRUE, pE, pS))
  xActive <- x[which(isActive[1:i])]
  xControl <- x[which(!isActive[1:i])]

  for (k in seq_len(sim)) {
    if (length(nn) != 1 && wiggle) {
      # randomly generate look locations
      dist <- h_get_distance(nn = nn)
      nnr <- h_get_looks(dist = dist, nnE = nnE, nnF = nnF) # we generate sim number of looks
      nnrE <- nnr$nnrE
      nnrF <- nnr$nnrF
    } else {
      nnrE <- nnE
      nnrF <- nnF
    }
    nnr <- unique(c(nnrE, nnrF))

    tmp <- h_rct_get_decisionDist(
      nnr = nnr,
      nnrE = nnrE,
      nnrF = nnrF,
      truep = truep,
      parE = c(1, 1),
      tL = tL,
      tU = tU,
      deltaE = deltaE,
      deltaF = deltaF,
      relativeDelta = relativeDelta
    )
    decision[k] <- tmp$decision
    all_sizes[k] <- tmp$all_sizes
  }
  # n[k] <- i
  #  nActive[k] <- length(xActive)
  #  nControl[k] <- length(xControl)
  #
  #  j <- j + 1
  #  i <- nnr[j]

  oc <- h_get_oc(all_sizes = all_sizes, nnr = nnr, decision = decision, nnrE = nnrE, nnrF = nnrF)
  list(
    oc = oc,
    ExpectedN = mean(n),
    ExpectedNactive = mean(nActive),
    ExpectedNcontrol = mean(nControl),
    Decision = decision,
    SampleSize = all_sizes,
    union_nn = nnr,
    input_nnE = nnE,
    input_nnF = nnF,
    wiggled_nnE = nnrE,
    wiggled_nnF = nnrF,
    wiggle_dist = dist,
    params = as.list(match.call(expand.dots = FALSE))
  )
}
```

```{r}
ocRctPostprobDist <- function(nn, pE, pS, deltaE, deltaF, relativeDelta = FALSE,
                              tL = 0.8, tU = 0.8,
                              parE = c(a = 1, b = 1),
                              parS = c(a = 1, b = 1),
                              randRatio = 1,
                              ns = 10000, nr = FALSE, d = NULL, nnF = nn) {
  ## checks
  stopifnot(
    is.probability(pE),
    is.probability(pS),
    is.probability(deltaE),
    is.bool(relativeDelta),
    is.probability(tL),
    is.probability(tU),
    randRatio > 0,
    is.scalar(ns),
    is.bool(nr)
  )

  if (!is.null(deltaF)) {
    stopifnot(is.probability(abs(deltaF)))
  }


  ## s: decision reject H0 (TRUE) or fail to reject (FALSE)
  ##    during trial if continuing (NA)
  nnE <- sort(nn)
  nnF <- sort(nnF)
  s <- rep(NA, ns)
  n <- nActive <- nControl <- integer(length(s))
  ns <- as.integer(ns)
  nn <- sort(unique(c(nnF, nnE)))
  nL <- length(nn) # 3rd
  Nstart <- nn[1] # first element 10
  Nmax <- nn[nL] # third element  30

  ## proportion of active patients:
  activeProp <- randRatio / (randRatio + 1) # 0.5

  ## determine number of active and control patients
  NmaxActive <- ceiling(activeProp * Nmax) # 15 patients max that active can have
  NmaxControl <- Nmax - NmaxActive # 15 patients max that control patients can have

  if (nr && is.null(d)) { # if no distance given, distance is measured. So this is get_distance
    ## set parameter d for randomly generating look locations
    d <- floor(min(nn - c(0, nn[-nL])) / 2) # 3, c(10, 20, 30)
  }
  nnr <- nn # c(10, 20, 30)
  nnrE <- nnE # c(10, 20, 30)
  nnrF <- nnF # c(10, 20, 30)
  ## simulate a clinical trial ns times

  for (k in 1:ns) {
    if (nr && (d > 0)) { # if distance given, then distance will be calculated as wiggled distance
      ## randomly generate look locations
      dd <- sample(-d:d,
        size = nL - 1, replace = TRUE,
        prob = 2^(c(-d:0, rev(-d:(-1))) / 2)
      )
      nnr <- nn + c(dd, 0)
      nnrE <- nnr[nn %in% nnE]
      nnrF <- nnr[nn %in% nnF]
    }

    ## simulate sequence of patients
    isActive <- sample(
      x = rep(c(TRUE, FALSE), c(NmaxActive, NmaxControl)), # active pts have an NmaxActive counts
      size = Nmax,
      replace = FALSE
    )
    #  [1]  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE
    # [15] FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE
    # [29] FALSE  TRUE
    ## simulate sequence of responses. So for each above, generate a 1 or 0 according to pE and pS
    x <- stats::rbinom(Nmax, 1,
      prob = ifelse(isActive, pE, pS) # out of all patients, if isActive == TRUE, the prob of success is pE, otherwise pS
    )
    # [1] 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 1 0 0 0 1 1 0 0 1 0 1 0 0 0 1
    ## start trial
    j <- 1
    i <- nnr[j]

    while (is.na(s[k]) && (j <= length(nnr))) { # when there is no decision and we are look 1, 2, 3.
      ## current data in both arms:
      xActive <- x[which(isActive[1:i])] # [1] 0 0 1 0 4 patients here
      xControl <- x[which(!isActive[1:i])] # [1] 0 0 0 0 0 0 6 patients here

      ## compute the two probabilities
      if (!is.null(deltaF) && i %in% nnrF) { # if there is an nnF, and a size look that is in nnrF
        qL <- postprobDist(
          x = sum(xControl), n = length(xControl),
          xS = sum(xActive), nS = length(xActive),
          delta = deltaF,
          relativeDelta = relativeDelta,
          parE = parS, parS = parE
        )
      }

      qU <- postprobDist(
        x = sum(xActive), n = length(xActive),
        xS = sum(xControl), nS = length(xControl),
        delta = deltaE,
        relativeDelta = relativeDelta,
        parE = parE, parS = parS
      )

      if (!is.null(deltaF)) { # if there is a deltaF
        if (i %in% nnrF) {
          s[k] <- ifelse(qL >= tL, FALSE, NA)
        }

        if (i %in% nnrE) { # if size look is in nnrE
          s[k] <- ifelse(qU < tU, s[k], TRUE)
        }
      } else {
        if (i %in% nnrF) {
          s[k] <- ifelse(qU <= 1 - tL, FALSE, NA)
        }

        if (i %in% nnrE) {
          s[k] <- ifelse(qU < tU, s[k], TRUE)
        }
      }

      ## sample sizes: total and in both arms
      n[k] <- i
      nActive[k] <- length(xActive)
      nControl[k] <- length(xControl)

      j <- j + 1
      i <- nnr[j]
    }
  }

  oc <- cbind(
    ExpectedN = mean(n),
    ExpectedNactive = mean(nActive),
    ExpectedNcontrol = mean(nControl),
    PrStopEarly = mean(n < Nmax),
    PrEarlyEff = sum(s * (n < Nmax), na.rm = TRUE) / ns,
    PrEarlyFut = sum((1 - s) * (n < Nmax), na.rm = TRUE) / ns,
    PrEfficacy = sum(s, na.rm = TRUE) / ns,
    PrFutility = sum(1 - s, na.rm = TRUE) / ns,
    PrGrayZone = sum(is.na(s) / ns)
  )

  return(list(
    oc = oc, Decision = s, SampleSize = n,
    SampleSizeActive = nActive,
    SampleSizeControl = nControl,
    nn = nn, nnE = nnE, nnF = nnF,
    params = as.list(match.call(expand.dots = FALSE))
  ))
}
```
